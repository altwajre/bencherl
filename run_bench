#!/bin/bash

# Runs one or more benchmarks.
# Usage: ./run_bench <options> 

# Display information about how this script can be used.
usage()
{
	cat << EOF
Usage: run_bench [OPTION..]
Run scalability benchmarks.

 -b <B>  run the specified benchmark(s) 
         (e.g. big or bang,big) 
         (default: all)  
 -c      perform sanity check
 -h      display this help and exit
 -i <N>  run the benchmark(s) N times 
         (default: 1) 
 -l      list all the available benchmarks
 -m      use the specified mnemonic name for the results
 -n <N>  use N nodes 
         (e.g. 1 or 1..4 or 1,5,6) 
         (default: 0)
 -p      plot diagrams
 -s <N>  use N schedulers 
         (e.g. 1 or 1..4 or 1,5,6) 
         (default: as many as the cores)

For complete documentation, go to ...
EOF
}

spin()
{
	while ps | grep $1 &>/dev/null; do
		i=0
		while [ "$i" -lt "3" ]; do
			echo -n "."
			i=$[$i+1]
			sleep 0.5
		done
		i=0
		while [ "$i" -lt "3" ]; do
    	    echo -ne '\b \b'
			i=$[$i+1]
			sleep 0.5
		done
    done
	echo -n '...'
}

# Display a list with all the available benchmarks.
list_bms()
{
	echo -n "Benchmarks:"
	for b in `ls bench`; do
		if [ -d bench/$b ]; then
			echo -n " $b"
		fi
	done
	echo
}

# Run a benchmark.
run_bm()
{
	# Create the output directory for this benchmark.
	mkdir -p $odir

	# Create the statistics directory for this benchmark.
	mkdir -p $sdir

	# For each OTP.
	for otp in $OTPS; do

		otpl=${otp%%=*}
		otpv=${otp##*=}

		# For each VM args set.
		for args in $ARGS; do	
			
			argsl=${args%%=*}
			argsv=${args##*=}

			IFS=$OLD_IFS
			n=`echo $NDS | tr "," "\n" | tail -n 1`
			IFS=$MY_IFS
			if [ "$n" -gt "$NNODES" ]; then
				n=$NNODES
			fi
			# For each number of schedulers.
			for s in $SCS; do
				WHAT="sched"
				do_run_bm
			done

			IFS=$OLD_IFS
			s=`echo $SCS | tr "," "\n" | tail -n 1`
			IFS=$MY_IFS
			# For each number of nodes.
			for n in $NDS; do
				if [ "$n" -gt "$NNODES" ]; then
					continue
				fi
				WHAT="node"
				do_run_bm
			done
		done
	done
}

# Do run the benchmark.
do_run_bm()
{

	IFS=$OLD_IFS
	
	# Run the pre_bench script (if there is one).
	if [ -f bench/$bench/conf/pre_bench ]; then
		bench/$bench/conf/pre_bench $s "$otpv" "$argsv"	
	fi

	# Create the configuration file that is necessary for running the 
	# benchmark.
	benchdir=`cd bench/$bench; pwd`

	if [ -z $otpv ]; then	
		erl="erl"
	else
		erl="$otpv/bin/erl"
	fi

cat > scratch/run_bench.config << EOF
{bench, $bench}.
{otp, "$otpv"}.
{args, "$argsv $EXTRA_ARGS +S$s:$s -noshell -pa $CODE_PATH suite/ebin bench/$bench/ebin -setcookie $COOKIE" }.
{nnodes, $n}.
{nschedulers, $s}.
{nodes, [$NODES]}.
{iterations, $ITERATIONS}.
{outfile, "$odir/$otpl.$argsl.$s.$n.output"}.
{statfile, "$sdir/$otpl.$argsl.$WHAT.time"}.
{datadir, "$benchdir/data"}.
{what, $WHAT}.
EOF

	# Run the benchmark.
	hostname=`hostname -f`
		${erl} ${argsv} ${EXTRA_ARGS} -setcookie "${COOKIE}" +S$s:$s \
		-name master@${hostname} -noshell -pa ${CODE_PATH} \
		suite/ebin bench/$bench/ebin -s run_bench main -s erlang \
		halt

	# Run the post_bench script (if there is one).
	if [ -f bench/$bench/conf/post_bench ]; then
		bench/$bench/conf/post_bench $s "$otpv" "$argsv"
	fi

	IFS=$MY_IFS
}

# Perform sanity check on the results of a benchmark.
check_bm()
{
	local succeeded=1
	NF=`ls -1 $bdir/output/*.output | wc -l`
	if [ "$NF" -gt "1" ]; then	
		BF=`ls -1 $bdir/output/*.output | head -n 1`
		for f in `ls $bdir/output/*.output`; do
			diff=`diff -B -q $BF $f`
			if [ ! -z "$diff" ]; then
				succeeded=0
				break
			fi
		done
	fi
	return $succeeded
}

# Plot diagrams for a benchmark.
plot_bm()
{

	# Create the diagrams directory.
	mkdir -p $ddir

	# Plot time diagrams.
	if [[ ( "$NNODES" -gt "1" ) && ( "$NNDS" -gt "1" ) ]]; then
		WHAT=node.time
		plot
	fi
	if [ "$NSCS" -gt "1" ]; then
		WHAT=sched.time
		plot
	fi

	# Plot speedup diagrams.
	if [[ ("$NNODES" -gt "1" ) && ( "$NNDS" -gt "1") ]]; then
		for file in `ls $sdir/*.*.node.time`; do
			fn=`basename $file .node.time`
			cat $sdir/$fn.node.time | ./suite/speedup.awk >> $sdir/$fn.node.speedup
		done
		WHAT=node.speedup
		plot
	fi
	if [ "$NSCS" -gt "1" ]; then
		for file in `ls $sdir/*.*.sched.time`; do
			fn=`basename $file .sched.time`
			cat $sdir/$fn.sched.time | ./suite/speedup.awk >> $sdir/$fn.sched.speedup
		done
		WHAT=sched.speedup
		plot	
	fi
}

# Plot.
plot()
{

	what1=${WHAT%%.*}
	what2=${WHAT##.*}
	
	if [ "$what1" == "time" ]; then
		yal="Time (ms)"
	else
		yal="Speedup"	
	fi

	if [ "$what2" == "sched" ]; then
		xal="# Schedulers"
	else
		xal="# Nodes"
	fi

	# Plot a diagram for each OTP-VM args combination.
	for file in `ls $sdir/*.$WHAT`; do
		fn=`basename $file .$WHAT`
		otp=${fn%%.*}
		args=${fn##*.}
		PARGS="$PARGS $args"
		POTPS="$POTPS $otp"
		./suite/plot.pl "$bench - $otp - $args" \
		"$xal" "$yal" "$sdir/$fn.$WHAT" \
		"$ddir/$fn.$WHAT.ps"
	done

	POTPS=`echo $POTPS | tr " " "\n" | sort -du | tr "\n" " "`
	PARGS=`echo $PARGS | tr " " "\n" | sort -du | tr "\n" " "`
	NOTPS=`echo $POTPS | wc -w`
	NARGS=`echo $PARGS | wc -w`

	# Plot a diagram for each OTP.
	if [ "$NARGS" -gt "1" ]; then
		for otp in $POTPS; do
			for file in `ls $sdir/$otp.*.$WHAT`; do
				fn=`basename $file .$WHAT`
				otp=${fn%%.*}
				args=${fn##*.}
				cat $sdir/$fn.$WHAT | ./suite/inject.awk \
				what=$args > $sdir/$fn.tmp
			done
			cat `ls $sdir/$otp.*.tmp` | sort -g | ./suite/merge.awk \
			> $sdir/$otp.$WHAT
			./suite/plot.pl "$bench - $otp" \
			"$xal" "$yal" "$sdir/$otp.$WHAT" \
			"$ddir/$otp.$WHAT.ps"
		done
	fi

	# Plot a diagram for each VM args set.
	if [ $NOTPS -gt 1 ]; then
		for args in $PARGS; do
			for file in `ls $sdir/*.$args.$WHAT`; do
				fn=`basename $file .$WHAT`
				otp=${fn%%.*}
				args=${fn##*.}
				cat $sdir/$fn.$WHAT | ./suite/inject.awk \
				what=$otp > $sdir/$fn.tmp
			done
			cat `ls $sdir/*.$args.tmp` | sort -g | \
			./suite/merge.awk > $sdir/$args.$WHAT
			./suite/plot.pl "$bench - $args" \
			"$xal" "$yal" "$sdir/$args.$WHAT" \
			"$ddir/$args.$WHAT.ps"
		done
	fi
	rm -rf $sdir/*.tmp
}

# Handle the specified options.
while getopts ":b:chlm:s:n:pi:" opt; do
	case $opt in
		b)
			BMS=$OPTARG
			;;
		c)
			SANITY_CHECK=1
			;;
		h)
			usage
			exit 0
			;;
		i)
			ITERATIONS=$OPTARG
			;;
		l)
			list_bms
			exit 0
			;;
		m)
			MNEMONIC_NAME=$OPTARG
			;;
		n)
			NDS=$OPTARG
			;;
		p)
			PLOT=1
			;;
		s)
			SCS=$OPTARG
			;;
		\?)	
			echo "Invalid option: -$OPTARG"	
			exit 1
			;;
	esac
done

# Handle the specified number of schedulers.
if [ -z $SCS ]; then
	SCS=`cat /proc/cpuinfo | grep processor | wc -l`
fi
if [[ "$SCS" =~ .*\.\..* ]]; then
	min=`echo $SCS | cut -d'.' -f1`
	max=`echo $SCS | cut -d'.' -f3`
	SCS=`seq $min $max`
else
	SCS=`echo $SCS | sed 's/,/ /g'`
fi 
x=`echo $SCS | tr " " "\n" | wc -l`
if [ $x -ne 1 ]; then
	SCS="1 $SCS"
fi
SCS=`echo $SCS | tr " " "\n" | sort -gu | tr "\n" ","`
L=${#SCS}
L=$(( L - 1 ))
SCS=${SCS:0:L}
NSCS=`echo $SCS | tr "," "\n" | wc -l`

# Handle the specified number of nodes.
if [ -z $NDS ]; then
	NDS=0
fi
if [[ "$NDS" =~ .*\.\..* ]]; then
    min=`echo $NDS | cut -d'.' -f1`
    max=`echo $NDS | cut -d'.' -f3`
    NDS=`seq $min $max`
else
    NDS=`echo $NDS | sed 's/,/ /g'`
fi
NDS=`echo $NDS | tr " " "\n" | sort -gu | tr "\n" ","`
L=${#NDS}
L=$(( L - 1 ))
NDS=${NDS:0:L}
NNDS=`echo $NDS | tr "," "\n" | wc -l`

# Handle the specified number of iterations.
if [ -z $ITERATIONS ]; then
	ITERATIONS=1
fi

# Handle the mnemonic name.
if [ -z $MNEMONIC_NAME ]; then
	MNEMONIC_NAME=`date +%d.%m.%y.-%H.%M.%S`
fi
 
# Configure the suite.
source conf/suite.conf

# These are the default OTP, VM args, cookie and nodes. 
DEF_OTPS=${OTPS:-"DEFOTP="}
DEF_ARGS=${ARGS:-"DEFARGS= "}
DEF_COOKIE=${COOKIE:-"erl_bench_cookie"}
DEF_NODES=${NODES:-""}

# If no benchmark has been specified, then run all benchmarks.
if [ -z "$BMS" ]; then
    for b in `ls bench`; do
        if [ -d bench/$b ]; then
			if [ -z "$BMS" ]; then
				BMS="$b"
			else
				BMS="$BMS,$b"
			fi
        fi
    done
fi

OLD_IFS=$IFS
MY_IFS=$','

# Create a new directory in the results directory.
if [ -e results/$MNEMONIC_NAME ]; then
	rm -rf results/$MNEMONIC_NAME
fi
dir=results/$MNEMONIC_NAME
mkdir $dir

# For each one of the specified benchmarks.
IFS=$MY_IFS
for bench in $BMS; do

	IFS=$OLD_IFS
	
	# There is no benchmark with this name.
	if [ ! -d bench/$bench ]; then
        echo "Unknown benchmark: $bench"

	# This benchmark must be ignored.
    elif [[ "$IGNORE_BENCH" =~ "$bench" ]]; then
        echo "Ignored benchmark: $bench"

	# Do something about this benchmark.
    else

		echo "Benchmark: $bench"

		# Restore OTP, VM args, cookie and nodes to their default values.
		OTPS=$DEF_OTPS
		ARGS=$DEF_ARGS
		COOKIE=$DEF_COOKIE
		NODES=$DEF_NODES

		# Do the same for the code path and the extra VM args.
		CODE_PATH=
		EXTRA_ARGS=

		# The different benchmark-related directories.
		bdir=$dir/$bench
		odir=$bdir/output
		sdir=$bdir/statistics
		ddir=$bdir/diagrams

		# Create the directory for this benchmark.
		mkdir -p $bdir

		# Configure the benchmark.
		if [ -f bench/$bench/conf/bench.conf ]; then
			source bench/$bench/conf/bench.conf
		fi

		# Count the nodes.
		NNODES=`echo $NODES | tr "," "\n" | wc -l`

		IFS=$MY_IFS

		# Run this benchmark.
		echo -n "Running"
		run_bm &
		spin $!
		echo " done"

		IFS=$OLD_IFS

		# Perform sanity check on the results of this benchmark.
		if [ "$SANITY_CHECK" == "1" ]; then
			echo -n "Performing sanity check..."
			check_bm
			if [ "$?" -eq "1" ]; then
				echo " succeeded"
			else
				echo " failed"
			fi
		fi

		# Plot.
		if [[ ( "$PLOT" -eq "1" ) && ( ( "$NNDS" -ne "1" ) || ( "$NSCS" -ne "1" ) ) ]]; then
			echo -n "Plotting"
			plot_bm &
			spin $!
			echo " done"
		fi
	fi

	IFS=$MY_IFS

done


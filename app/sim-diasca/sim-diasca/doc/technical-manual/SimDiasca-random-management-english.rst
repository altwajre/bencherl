:raw-latex:`\pagebreak`

-------------------------------------------
Sim-Diasca Management of Probabilistic Laws
-------------------------------------------


Principles
==========

Quite often models make use of stochastic variables.

Such variables - respecting a given probabilistic law - are very useful to model the behaviours of simulation actors.

For example, in terms of reliability, the approach is generally to define per-equipment average constants like the *Mean Time To Failure* (MTTF) and the *Mean Time To Repair* [#]_ (MTTR), and to express reliability models thanks to stochastic laws parameterised by these constants (in that case: exponential and Gaussian laws, respectively).


.. [#] MTTR is also known as *Mean Time To Recovery*.


Stochastic variables are also very useful when *generating* variations on a theme, in the context of the simulation of a large number of instances of a given case.

For example, when wanting to simulate a wide range of different low-voltage meshes, one can either:

 - load a set of externally-defined descriptions of real meshes coming from the field (should such descriptions be available, accurate and numerous enough)

 - or, more easily, one can *generate* these different meshes according to some probabilistic rules, which would give, for example, the number of supply points of a given mesh, depending on its profile (ex: rural, urban, etc.), so that the pool of generated meshes follows the real-life statistics


The objective here is therefore to provide model developers with all the facilities needed to easily specify and implement stochastic models, in full compliance with the aforementioned simulation properties. This involves a little more than that:

:raw-html:`<img src="xkcd-random_number.png"></img>`
:raw-latex:`\includegraphics[scale=0.7]{xkcd-random_number.png}`




Built-in Random Distributions
=============================

Although any probabilistic distribution (i.e. probability density) can be defined and added to the framework, Sim-Diasca provides some built-in distributions, listed below, that are among the most common.

They are proposed by the ``RandomManager``, a specific technical component helping to manage stochastic variables in the context of a distributed simulation, notably so that causality and reproducibility are preserved.


Uniform Law
-----------

This "white noise" generator will draw values into a user-parameterised range, all samples having an equal probability of being chosen.

When placing a Sim-Diasca `probe`_ at the output of a RandomManager set to deliver a uniform law, we have the following result:

:raw-html:`<img src="RandomManager-Uniform_probe.png"></img>`
:raw-latex:`\includegraphics[scale=0.6]{RandomManager-Uniform_probe.png}`

By setting the appropriate flag, Sim-Diasca can also be configured to use a uniform generator of superior quality, which was designed for cryptography.

This uniform distribution is often the basis to generate in turn more complex distributions.


Exponential Law
---------------

This distribution, defined by a single parameter, ``lambda``, leads to the following result:

:raw-html:`<img src="RandomManager-Exponential_probe.png"></img>`
:raw-latex:`\includegraphics[scale=0.6]{RandomManager-Exponential_probe.png}`

This distribution is directly generated by Sim-Diasca from the previous white noise source.



Gaussian Law
------------

Two parameters, ``mu``, the mean value, et ``sigma``, the variance (whose positive square root is the standard deviation), define the Gaussian law [#]_.

.. [#] It is also known as the normal law.

This results in the following curve:

:raw-html:`<img src="RandomManager-Gaussian_probe.png"></img>`
:raw-latex:`\includegraphics[scale=0.6]{RandomManager-Gaussian_probe.png}`

The Sim-Diasca white noise generator is used to generate this Gaussian law as well.



Actual Management of Randomness
===============================


Mode Of Operation
-----------------

Random generators usually have a state, which is hidden and initialised with a seed, either set by default or specifically given.

From the seed a series of random numbers can be generated, and as such it can be reproduced identically, as long as the same seed is used.

The trouble comes from the fact that, during a given tick, multiple simulation actors may require - and therefore request - random values in any order.

Sim-Diasca provides two different methods to support this.

Both of them allow a simulation actor to define any number of random variables it will be using, each parameterised as wished, on a per-actor basis.

As these methods result in different trade-offs regarding resource consumption, they are both useful, depending on the context.



Method #1: Stochastic Actors
----------------------------

The most obvious approach is to have actors require the random values they need to a centralised random manager.

This solution is simple, but has some pitfalls.

First point is **not to break reproducibility**. Indeed, without any specific measure, actors would request their value to the centralised random manager during the execution of their tick, with no particular order enforced between requests, since they would be concurrent in that context.

Therefore, if, thanks to the seeding, they would indeed consume collectively always the same random series, the values of this series would be differently dispatched among actors, depending on the chronological order of reception of their requests by the random manager.

The solution is to **have the random manager become a simulator actor** as well. Then it would be appropriately synchronised by the mechanisms provided by the time manager, and stochastic actors would thus behave correctly and in a reproducible way.

There is an issue there nevertheless. Indeed, if the model of an actor required that actor to use a random value at a given tick N, then to have that value the actor would have to send a request during this tick to the random manager, which would process that request during the next tick (i.e. N+1) and send back the determined value to the requesting actor, which would in turn be able to process it no sooner than the next tick (N+2).

Therefore this would induce by default an **unwanted 2-tick latency** each time an actor would require a random value, whereas the model does not tell so. As some actors can consume at least one value per tick, the system cannot work as is.

Moreover, not all actors are able to anticipate on their needs of random values, and, in the cases where it would be possible, doing so would make their implementation a lot more complex than needed.

Hence a generic solution was designed instead, that would manage transparently these needs, i.e. with no impact on models.

The solution consists on having each actor that uses stochastic variables define, for each one of them, not only which distribution law with which settings should be used, but also an **upper bound to the number of values following that law that may be drawn during any single tick**, for this actor and this distribution.

Such an upper bound should be possible to define for most if not all models.

With these information, the generic *stochastic actor* (a Sim-Diasca built-in) is able to transparently cache full lists of random variables obtained from the random manager, and to manage their refilling appropriately in the background, so that the corresponding random values can be always obtained with zero latency by the actor.

Thus **the implementation of models is considerably simplified**, since they can be developed as if they could rely on local infinite random sources, which additionally would not raise issues about reproducibility.

This first mechanism is implemented by a specialised generic actor, the ``Stochastic Actor``, which can be reused at will be all stochastic models to simplify their development.

If ever the upper bound was incorrectly evaluated (i.e. if it was set to a too small value, leading to an exhaustion of the corresponding random buffer), then at simulation time the issue would be detected and the simulation would stop. Then the upper-bound could just be set to a higher value, and the simulation be run again.



Method #2: Private Random Managers
----------------------------------

There are some cases where the stochastic actors previously described would not be appropriate or convenient:

 - in some cases, maybe no upper-bound to the consumption of random values for a given model during one tick can be determined (even if one model designer can request to buffer a number of random values as high as needed)

 - some stochastic actors need random variables whose probabilistic distributions can change during a simulation. For example, if a meter determines its connectivity by drawing, with equal probability, a given number of meters out of its functional upstream meters, this translates into a uniform law whose range can change at each tick (depending on how many upstream meters are functional)

The most convenient way of dealing with these cases is to have each corresponding stochastic actor rely on its **own private random manager**.

Sim-Diasca offers a way of creating such private random managers appropriately. The preservation of reproducibility is mostly a matter of seeding them correctly: there is a *main* random manager, which will be requested to create each private random manager thanks to actor messages, which therefore will be synchronised.

This main random manager will then seed them on creation, based on its internally-managed random series.

As a consequence, reproducibility will be ensured, and actors will, once their random manager will be created accordingly, be able to interact with it with no further synchronisation effort, i.e. with no delay, and with direct (i.e. non-actor) messages.

This convenient method should not be too widely generalised nevertheless, as it involves **one extra process per stochastic actor**, which may hinder scalability. Therefore the previous stochastic actors should be favoured in most cases.
